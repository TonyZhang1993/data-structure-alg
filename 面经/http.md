```js
1 GET和POST是HTTP协议中的两种请求方法,它们之间存在一些重要的区别,主要体现在以下方面: 

- 请求参数的位置: GET请求的请求参数会附加在URL之后,参数之间使用"&"连接,多个参数将会造成URL长度增加. 而POST请求的请求参数则包含在请求体中,不会在URL中显示. 
- 请求长度的限制: 由于GET请求的参数附加在URL之后,因此其请求长度受限于浏览器对URL长度的限制(通常浏览器对URL的长度有限制,而服务器对URL的长度限制更为宽松). 而POST请求则没有这个问题,请求参数包含在请求体中,因此可以传输大量数据. 
- 安全性: GET请求的参数会暴露在URL中,因此不能用于传输敏感信息,如密码等. 而POST请求的参数在请求体中,不会在URL中显示,相对更加安全. 然而,这并不意味着POST请求就一定比GET请求更安全,因为安全性还需要依赖于其他因素,如SSL/TLS加密等. 
- 缓存: GET请求可以被缓存,而POST请求则不会,除非在响应头中包含适当的Cache-Control或Expires字段. 

2 HTTP/2相对于HTTP/1.x具有显著的优势和特点,主要体现在以下几个方面: 

二进制分帧层: HTTP/2不再使用文本格式来传输数据,而是将所有传输的信息分割为更小的消息和帧(frame),并以二进制格式进行编码. 这有助于更高效地解析HTTP消息,并减少了解析错误的可能性. 
多路复用: HTTP/2引入了多路复用技术,允许在单个TCP连接中并行处理多个请求和响应. 这消除了HTTP/1.x中的队头阻塞问题,极大地提高了网络性能和资源利用率. 
头部压缩: HTTP/2使用了头部压缩技术,通过共享头部信息,可以显著减少传输的数据量. 这有助于减少延迟和网络带宽的消耗,特别是在传输大量小请求时效果更为显著. 
服务器推送: HTTP/2允许服务器主动向客户端推送资源,而无需等待客户端的请求. 这有助于减少往返时间,并提高网页加载速度. 
流量控制: HTTP/2通过流控制, 消息控制和窗口控制等机制,实现了对流量的精细控制,有助于防止网络拥塞和资源浪费. 

3 HTTPS之所以比HTTP更安全,主要是通过以下几种机制来保证其安全性: 

-加密传输: HTTPS使用SSL/TLS协议对HTTP报文进行加密,使得敏感数据在网络传输过程中不容易被窃听和篡改. 这种加密过程结合了对称加密和非对称加密,确保数据的保密性和完整性. 
-身份验证: HTTPS通过数字证书进行身份验证,确保通信双方的真实性. 在建立HTTPS连接时,服务器会提供数字证书来证明自己的身份. 如果验证通过,客户端就可以信任服务器,并继续与其进行安全的数据传输. 这有效防止了被恶意伪装的服务器攻击. 
-数据完整性保护: 在传输数据之前,HTTPS会对数据进行加密,并使用消息摘要(hash)算法生成一个摘要值. 在数据到达接收端后,接收端会使用相同的算法对接收到的数据进行摘要计算,并与发送端的摘要值进行比较. 如果两者一致,说明数据在传输过程中没有被篡改. 如果不一致,通信双方应重新进行验证或中断连接. 

3xx(重定向状态码): 

301 Moved Permanently: 请求的资源已被永久移动到新的URL上. 
302 Found: 请求的资源现在临时从不同的URL响应请求. 
304 Not Modified: 客户端已经执行了GET请求,但文件未发生变化. 


在HTTP/1.0中,需要在请求头中显式添加"Connection: keep-alive"来启用该机制; 而在HTTP/1.1中,keep-alive是默认启用的. 
总的来说,HTTP的keep-alive机制通过重用TCP连接和优化请求处理流程,提高了HTTP通信的性能和效率. 
- 减少连接建立开销: 在没有keep-alive的情况下,每次HTTP请求都需要经过TCP三次握手建立连接,这会导致较大的延迟和资源消耗. 而使用keep-alive,可以在一个TCP连接上发送多个HTTP请求,从而减少了建立连接的开销. 
- 降低网络负载: 每次建立和关闭连接时,都会消耗网络带宽和服务器资源. 通过保持持久连接,可以减少连接的频繁建立和关闭,从而降低了网络负载和服务器负载. 

从输入URL 到 页面加载的整个过程
1 用户输入URL: 用户首先在浏览器地址栏中输入想要访问的网站的URL. 
2 浏览器解析URL: 浏览器内部代码会解析这个URL. 它首先会检查本地hosts文件,看是否有对应的域名. 如果有,浏览器就会直接向该IP地址发送请求. 如果没有,浏览器会将域名发送给DNS服务器进行解析,将域名转换成对应的服务器IP地址. 
3 建立TCP连接: 浏览器得到IP地址后,会通过TCP协议与服务器建立连接. TCP/IP协议是Internet的基础,它负责确保数据在网络中的可靠传输. 这一过程中会进行三次握手,确保双方都已准备好进行通信. 
4 发送HTTP请求: TCP连接建立后,浏览器会向服务器发送HTTP请求. 这个请求包含了请求行(如GET方法, 请求的URI, HTTP版本等), 请求头部(如Accept-Charset, Accept-Encoding等)以及可能存在的请求正文. 
5 服务器处理请求: 服务器收到请求后,会根据请求的内容进行相应的处理. 这可能包括查询数据库, 生成动态内容等. 
6 发送HTTP响应: 服务器处理完请求后,会发送一个HTTP响应给浏览器. 这个响应包含了状态行(如HTTP版本, 状态码, 状态描述等), 响应头部(如Content-Type, Content-Length等)以及响应正文(即实际要显示的页面内容). 
7 浏览器解析和渲染页面: 浏览器收到响应后,会解析响应正文中的HTML代码,并下载所需的CSS, JavaScript等资源文件. 然后,浏览器会根据这些资源来渲染页面,最终将页面呈现给用户. 


浏览器缓存的优先级主要遵循以下顺序: 

Service Worker 缓存: 由于其可以完全控制网络请求,因此具有最高的优先级,即使是强制缓存也可以被它所覆盖. Service Worker是运行在浏览器背后的独立线程,一般可以用来实现缓存功能

Memory Cache(内存缓存) : 这是内存中的缓存,主要包含的是当前页面中已经抓取到的资源,如样式, 脚本, 图片等


HTTP Cache(HTTP缓存)-这包括强制缓存和协商缓存. 
- 强制缓存: 在有效时间内,不会向服务器发送请求,直接从缓存中读取资源. 控制强制缓存的字段分别是Expires和Cache-Control,其中Cache-Control的优先级高于Expires. 
- 协商缓存: 当强制缓存失效后,浏览器会携带缓存标识向服务器发起请求,由服务器根据缓存标识决定是否使用缓存. 控制协商缓存的字段有Last-Modified/If-Modified-Since和Etag/If-None-Match. 

强缓存与协商缓存的共同点是: 如果命中,都是从客户端缓存中加载资源,而不是从服务器加载资源数据; 区别是: 强缓存不发请求到服务器,协商缓存会发请求到服务器. 

强缓存是利用Expires或者Cache-Control这两个http response header实现
协商缓存是利用的是【Last-Modified,If-Modified-Since】和【ETag, If-None-Match】

HTTP请求头常用字段: Accept / Accept-Charset / Accept-Encoding /  Accept-Language, If-Modified-Since / If-None-Match, Host, Referer, User-Agent, Cookie, Connection, Date

HTTP响应头常用字段(响应头用于描述服务器的基本信息,以及数据的描述,服务器通过这些数据的描述信息,可以通知客户端如何处理等一会儿它回送的数据. ): 
Location, Server, Content-Encoding, Content-Length, Content-Type, Refresh, Content-Disposition, Tranfer-Encoding,
(缓存相关的字段)ETag, Last-Modified, Expires, Cache-Control, Pragma


同源策略是浏览器的一种安全机制,旨在防止一个域的脚本与另一个域的内容进行交互,以保护用户免受诸如跨站脚本攻击(XSS)和跨站请求伪造(CSRF)等安全威胁. 

浏览器渲染机制---
解析HTML并构建DOM树: 当浏览器接收到HTML文档后,它会解析HTML标签,将标签转换为DOM(文档对象模型)节点,并按照文档的结构将这些节点组织成一棵树形结构,即DOM树. DOM树是浏览器内部表示网页内容的一种方式,它包含了网页中所有的元素和属性. 
解析CSS并构建CSSOM树: 与此同时,浏览器也会解析CSS代码,将样式规则转换为CSSOM(CSS对象模型)节点,并构建成CSSOM树. CSSOM树描述了HTML文档中每个元素的样式信息. 
构建渲染树: 接下来,浏览器会将DOM树和CSSOM树合并成渲染树(Render Tree). 渲染树只包含需要显示的节点和样式信息,不包括隐藏的元素或不可见的样式. 这一步是渲染过程中的关键步骤,因为它决定了哪些元素将被渲染以及如何渲染. 
布局: 在构建完渲染树后,浏览器会根据渲染树的信息计算每个节点的位置和大小,生成布局. 这个过程也称为重排或回流,它涉及到对元素的位置和尺寸进行精确计算,以确保页面元素能够正确地显示在屏幕上. 
绘制: 布局完成后,浏览器会将每个节点的样式信息转换为像素,然后绘制到屏幕上. 这个过程也称为重绘,它涉及到将元素的视觉表现绘制出来. 

重排【回流】- 当页面布局或几何属性发生变化时, 比如宽高,位置等 
重绘 - 当页面中元素样式的改变不影响布局时, 颜色,背景色等

减少重绘和回流的方法: 
- 避免频繁操作样式: 尽量一次性修改多个样式属性,而不是逐一修改,以减少浏览器的重绘和回流次数. 

- 利用CSS3动画: CSS3动画和过渡不会触发回流,因为它们是通过GPU进行渲染的,这可以大大提高性能. 

- 避免使用table布局: table布局在发生变化时可能需要多次计算,这会增加回流次数. 尽量使用flexbox或grid等现代布局技术. 

- 批量修改DOM: 如果需要添加, 删除或修改多个DOM节点,可以考虑使用DocumentFragment或离线节点,这样可以在一次回流中完成所有操作. 

- 使用绝对定位: 绝对定位的元素不会触发其父元素及后续元素的回流,因为它们已经脱离了正常的文档流. 

- 避免使用内联样式: 内联样式会增加重绘和回流的可能性,因为它们会直接修改元素的样式. 尽量使用外部CSS文件来管理样式. 

* 浏览器事件机制
事件的传播过程分为三个阶段: 捕获阶段, 目标阶段和冒泡阶段. 在DOM2级事件模型中,事件首先在最外层HTML元素上开始捕获,然后向下传递到事件的目标元素,沿途触发所有设置了捕获事件处理器的元素. 接着,事件处理器在事件的目标元素上执行,这是事件处理的核心阶段. 最后,事件从目标元素向上回溯,触发所有设置了冒泡事件处理器的元素,完成冒泡阶段. 这种机制允许开发者在事件传播的不同阶段拦截并处理事件. 


进程是资源分配的基本单位,而线程是CPU调度的基本单位. 进程拥有独立的地址空间和资源,而线程共享进程的资源. 在并发性和系统开销方面,线程较进程具有更高的效率和更低的开销. 

1-----简要介绍一下XSS以及XSS如何防御
跨站脚本攻击是说攻击者通过注入恶意的脚本,在用户浏览网页的时候进行攻击,比如获取cookie或者其他用户身份信息.  可以分为存储型和反射型,
1. 转义字符 对于用户的输入应该是永远不信任的. 最普遍的做法就是转义输入输出的内容,对于引号, 尖括号, 斜杠进行转义. 
2. CSP CSP 本质上就是建立白名单,开发者明确告诉浏览器哪些外部资源可以加载和执行. 我们只需要配置规则,如何拦截是由浏览器自己实现的. 我们可以通过这种方式来尽量减少 XSS 攻击. 通常可以通过两种方式来开启 CSP: 1.设置 HTTP Header 中的 Content-Security-Policy; 2.设置 meta 标签的方式 . 
3. 输入内容长度控制
4. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie,攻击者完成 XSS 注入后也无法窃取此 Cookie. 
5. 验证码: 防止脚本冒充用户提交危险操作. 


2-----CSRF(跨站请求伪造)以及如何防御
攻击者诱导受害者进入第三方网站,在第三方网站中,向被攻击网站发送跨站请求. 利用受害者在被攻击网站已经获取的注册凭证,绕过后台的用户验证,达到冒充用户对被攻击的网站执行某项操作的目的. 
* 防御方法: 
1. 同源检测: 验证 HTTP Referer 或者 Origin 字段; 它记录了该 HTTP 请求的来源地址. 
2. 在请求地址中添加 token 并验证;  服务器下发一个随机 Token,每次发起请求时将 Token 携带上,服务器验证 Token 是否有效. 
3. 在 HTTP 头中自定义属性并验证. 把token放到HTTP头的自定义属性里面
4. 不让第三方网站访问到用户 Cookie.  可以对 Cookie 设置 SameSite 属性. 该属性表示 Cookie 不随着跨域请求发送,可以很大程度减少 CSRF 的攻击,但是该属性目前并不是所有浏览器都兼容. 

3-----cookie攻击
主要是利用JavaScript能够在当前域名下获取网站cookie的特性来攻击(javascript:alert(doucment.cookie)),一般来说可以配合XSS和CSRF来进行攻击,

避免攻击: 现在主流浏览器都支持在cookie上加上HttpOnly的属性,这样cookie就无法通过Java Script来取得,如果能在关键cookie上打上这个标记,对cookie的安全性的提高有很大作用. 

4------SQL注入
* 所谓SQL注入,就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串,最终达到欺骗服务器执行恶意的SQL命令.
* 防范方法: 
1. 永远不要信任用户的输入. 对用户的输入进行校验,可以通过正则表达式,或限制长度; 对单引号和双"-"进行转换等. 


```