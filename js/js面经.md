```js
JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol[生成唯一的值，解决变量冲突]、BigInt[任意精度的整数]

栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）
堆：引用数据类型（对象、数组和函数）

Object
- Array
- Date
- RegExp
- Function -> typeof Person === 'function'
- Set / Map


存储位置的不同：
- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。


判断数组的方式
1 Object.prototype.toString.call(new Array())
//  '[object Array]'

2 obj.__proto__ === Array.prototype

3 ES6的Array.isArray()

4 obj instanceof Array

5 Array.prototype.isPrototypeOf(obj)

this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。
使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

箭头函数中this的指向在它在定义时已经确定了，之后不会改变。

call()、apply()、bind()等方法不能改变箭头函数中this的指向

箭头函数不能作为构造函数使用

箭头函数没有自己的arguments; 在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。



ES6 Module和CommonJS模块的区别：

CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；
import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。

ES6 Module和CommonJS模块的共同点：

CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。


let、const、var的区别
（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
内层变量可能覆盖外层变量
用来计数的循环变量泄露为全局变量

（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。


new操作符的执行过程：
// 使用 new 操作符创建实例
var person1 = new Person('Alice', 25);

// 执行过程
var person1 = {}; // 创建一个新对象
person1.__proto__ = Person.prototype; // 将新对象与构造函数的原型对象关联
Person.call(person1, 'Alice', 25); // 执行构造函数，并将新对象作为 this 上下文

for...in 循环主要是为了遍历对象而生，不适用于遍历数组；
for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。【只遍历当前对象不会遍历原型链】

forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；
map()方法不会改变原数组的值，返回一个新数组


闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。【传入的promise对象返回的值是按照顺序在数组中排列的】

Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。

async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。


**垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

-   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。

 **1）标记清除**

-   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
-   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

**2）引用计数**

-   另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
-   这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。

## 减少垃圾回收
-   **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。
-   **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。
-   **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。

内存泄漏
循环引用：当两个对象相互引用，并且没有被其他对象引用时，这两个对象就会形成循环引用，导致内存泄漏。
定时器未清理：使用定时器时，如果定时器没有被正确清理，会导致定时器持续运行，占用内存。
缓存未清理：缓存是常见的内存泄漏原因之一，如果缓存中的数据长时间没有被清理，会导致内存泄漏。
事件监听器未移除：如果在DOM元素上添加了事件监听器，但是在元素被销毁或不再需要时没有移除事件监听器，会导致内存泄漏。
全局变量：全局变量会一直存在于内存中，如果不再需要的全局变量没有被释放，会导致内存泄漏。


匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码
(function () {
  // 一些代码。
})();

setTimeout(function () {
  console.log('Hello world!');
}, 1000);

柯里化（currying）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数

JS 设计模式
单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供一个全局访问点。

工厂模式（Factory Pattern）：通过工厂方法创建对象，而无需指定创建对象的具体类。

观察者模式（Observer Pattern）：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新。

策略模式（Strategy Pattern）：定义一系列算法，将每个算法封装起来，并使它们可以互相替换。

代理模式（Proxy Pattern）：控制对其他对象的访问，可以用于实现延迟加载、安全代理等功能。

适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。

装饰者模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责，就扩展功能而言，装饰模式比生成子类更为灵活。

命令模式（Command Pattern）：将请求封装成对象，以便使用不同的请求、队列或日志请求来参数化其他对象。

创建型模式，共五种：·工厂方法模式·、抽象工厂模式、·单例模式·、建造者模式、·原型模式·。
结构型模式，共七种：适配器模式、·装饰器模式·、·代理模式·、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、·观察者模式/发布订阅模式·


观察者模式 VS 发布订阅模式
从表面上看：
观察者模式里，只有两个角色 —— 观察者 + 被观察者
而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— {经纪人|Broker}



往更深层次讲：
观察者和被观察者，是松耦合的关系
发布者和订阅者，则完全不存在耦合


从使用层面上讲：
观察者模式，多用于单个应用内部
发布订阅模式，则更多的是一种{跨应用的模式|cross-application pattern} ，比如我们常用的消息中间件

```