## 知识回顾

> 浅拷贝只复制地址值,实际上还是指向同一堆内存中的数据
<br>深拷贝则是重新创建了一个相同的数据,修改属性不影响原来的值

数组/对象浅拷贝【如果里面的元素是基本类型的话,属于深拷贝】

```js
arr.slice()
arr.concat()
arr.forEach(...)
Object.assign(arr1, arr)  //  也可用于对象
const a2 = [...a1]  //  等同于 arr.slice()
```

常见的深拷贝方式有:

- _.cloneDeep(): lodash 库方法
```js
const obj2 = _.cloneDeep(obj1);
```

- jQuery.extend()
```js
const $ = require('jquery');
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

- JSON.stringify()
```js
const obj2=JSON.parse(JSON.stringify(obj1));
//  但是这种方式存在弊端,会忽略undefined symbol和函数
```

如何实现一个对象或者数组的浅拷贝
```js
var shallowCopy = function (target) {
  if (typeof target !== 'object') return 
  const result = Array.isArray(target) ? [] : {}
  //  遍历target属性,in 方法会遍历,不仅遍历对象自身属性,还会遍历继承的inumerable 属性
  for (ele in target) {
    //  判断是target自身的属性才拷贝
    if (target.hasOwnProperty(ele)) {
      result[ele] = target[ele]
    }
  }

  return result
}
```

手写循环递归 深拷贝
```js
var deepCopy = function (target) {
  if (typeof target !== 'object') return 
  const result = Array.isArray(target) ? [] : {}
  //  遍历target属性,in 方法会遍历,不仅遍历对象自身属性,还会遍历继承的inumerable 属性
  for (ele in target) {
    //  判断是target自身的属性才拷贝
    if (target.hasOwnProperty(ele)) {
      result[ele] = typeof target[ele] === 'object' ? deepCopy(target[ele]) : target[ele]
    }
  }

  return result
}
//  问题:值为null会赋值一个空对象
```

```js
//  对象循环引用的例子
const obj1 = {};
const obj2 = {};

obj1.ref = obj2;
obj2.ref = obj1;

console.log(obj1); // 输出: { ref: { ref: [Circular] } }
console.log(obj2); // 输出: { ref: { ref: [Circular] } }
```

比较完美的深拷贝例子
```js
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]'
}
function isDate(obj) {
  return Object.prototype.toString.call(obj) === '[object Date]'
}
function isSet(obj) {
  return Object.prototype.toString.call(obj) === '[object Set]'
}
function isObject(obj) {
  return typeof obj === 'object'
  // return Object.prototype.toString.call(obj) === '[object Object]'
}
function isArray(obj) {
  return Object.prototype.toString.call(obj) === '[object Array]' 
  //  return Array.isArray(obj)
}
//  涵盖所有类型的复制
function deepCopy(obj, map = new WeakMap()) {
  //  判断是否为regExp / Date / Set
  if (isRegExp(obj) || isDate(obj) || isSet(obj)) {
    return new obj.constructor(obj) //  类似于new Date()  ！！！记住加上参数
  }
  //  判断是否为null
  if (obj === null) return obj
  //  基本类型值 & function
  if (typeof obj !== 'object') return obj
  //  赋值循环引用的结果
  if (map.has(obj)) {
    return map.get(obj)
  }

  const cloneObj = Array.isArray(obj) ? [] : {}
  //  let cloneObj = new obj.constructor(); 与上一句话等价
  // 缓存循环引用的拷贝结果！！！！！！
  map.set(obj, cloneObj)
  //  会把原型链上的属性都遍历！！！！！
  for (let prop in obj) {
    //  过滤,仅复制自身属性！！！！！！！！
    if (obj.hasOwnProperty(prop)) {
      cloneObj[prop] = deepCopy(obj[prop])
    }
  }

  return cloneObj

}
```

补充知识点: 
```js
Set [Set类似于集合]
成员唯一 无序且不重复de 存储任何类型
[value, value], 键值与键名是一致的（或者说只有键值,没有键名）
可以遍历,方法有:add delete has
- new Set([1, 2, 3, 4])
- 使用 Array.from 将 Set 对象转换为数组对象 const myArr = Array.from(mySet1); 
- [...mySet] // 将 Set 对象转换为数组

WeakSet
成员都是对象
成员都是弱引用,可以被垃圾回收机制回收,可以用来保存DOM节点,不容易造成内存泄漏
不能遍历,方法有add delete has
const ws = new WeakSet();
const foo = {};
const bar = {};

ws.add(foo);
ws.add(bar);

ws.has(foo); // true
ws.has(bar); // true

Map [Map 是一种叫做字典的数据结构] key-value
本质上是键值对的集合
可以遍历,方法很多可以跟各种数据格式转换
const myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = function () {};

// 添加键
myMap.set(keyString, "和键'a string'关联的值");
myMap.set(keyObj, "和键 keyObj 关联的值");

WeakMap
只接受对象作为键名（null除外）,不接受其他类型的值作为键名
键名是弱引用,键值可以是任意的,键名所指向的对象可以被垃圾回收,此时键名是无效的
不能遍历,方法有get set has delete

const wm1 = new WeakMap();
const wm2 = new WeakMap();
const wm3 = new WeakMap();
const o1 = {};
const o2 = function () {};
const o3 = window;

wm1.set(o1, 37);
wm1.set(o2, "azerty");
```

