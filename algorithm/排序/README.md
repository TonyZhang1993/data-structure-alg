
排序或许是前端接触最多的算法了，很多人的算法之路是从一个冒泡排序开始的，排序的方法有非常多中，它们各自有各自的应用场景和优缺点，这里我推荐如下6种应用最多的排序方法，如果你有兴趣也可以研究下其他几种。

相关术语：
- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 
- 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 

- [冒泡排序](./冒泡排序.md)
> 循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。
![Alt text](../冒泡.gif)

平均时间复杂度：O(n²)

空间复杂度：O(1)

算法稳定性：稳定

- [插入排序](./插入排序.md)
> 将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。

![Alt text](../插入.gif)

平均时间复杂度：O(n²)

空间复杂度：O(1)

算法稳定性：稳定

- [选择排序](./选择排序.md)
> 每次排序取一个最大或最小的数字放到前面的有序序列中。

![Alt text](../选择.webp)

平均时间复杂度：O(n²)

空间复杂度：O(1)

算法稳定性：不稳定！！！

- [希尔排序](./希尔排序.md)
> 把数组分割成若干(h)个小组(一般数组长度length/2)，然后对每一个小组分别进行插入排序。每一轮分割的数组的个数逐步缩小，h/2->h/4->h/8，并且进行排序，保证有序。当h=1时，则数组排序完成。

平均时间复杂度：O(nlog2n)

算法空间复杂度：O(1)

算法稳定性：稳定

- [快速排序](./快速排序.md)
> 选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。

- [归并排序](./归并排序.md)
> 将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。

- [堆排序](./堆排序.md)
> 创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。
